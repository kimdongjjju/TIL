### 메모리 구조

```
1. 코드영역
    - 실행할 프로그램의 코드가 지정되는 영역
    - CPU에서 코드 영역에 저장된 명령어를 하나씩 가져가서 처리
2. 데이터 영역
    - 프로그램의 전역 변수와 정적 변수가 저장되는 영역
3. 스택 영역
    - 지역변수와 매개변수가 지정되는 영역
    - 함수의 호출과 함께 할당되며, 호출이 완료 시 소멸된다.
    - 높은 수준에서 낮은 수준 방향으로 할당
4. 힙 영역
    - 사용자가 직접 관리할 수 있는 메모리 영역
    - 메모리 공간이 동적으로 할당되고 해제 된다.
    - 모든 클래스의 인스턴스와 배열에 대한 메모리가 할당되는 영역
    - 낮은 수준에서 높은 수준으로 할당
```
-> 높은 수준, 낮은 수준이라는 말??은 작은 숫자의 메모리, 큰 숫자의 메모리로 할당되고 스택 과 힙이 반대방향으로 커기기 때문에 중간에서 출동하지 않게 된다.<br/>
-> 구현에 따라서 다를 수 있다.


### JIT 컴파일러란
> 인터프리터 방식의 단점을 보안하기 위해 도입되었고, 인터프리터 방식으로 실행하다가 적절한 시점에 <br/>
  바이트 코드 전체를 컴파일하여 기계어로 변경하여 기계어를 직접 실행하는 방식이다.

- 자바 컴파일러가 자바 프로그램 코드를 바이트 코드로 변환한 다음, 바이트 코드를 실행하는 시점에
  자바 가상 머신(JVM (JRE))이 바이트 코드를 JIT 컴파일로 기계어로 변환 한다.

### 클래스 로더
> JVM 내로 클래스 파일을 로드하고, Linking을 통해 배치하는 작업을 수행하는 모듈 <br/>
> 런타임시에 동적으로 클래스를 로드 함


### Runtime Data Area
> 프로그램 수행을 위해 OS에서 할당 받은 메모리 공간

### PC Register
> Thread가 실행될 때 생성되며, Thread마다 하나씩 존재 <br/>
> Thread가 어떤 부분을 어떤 명령어로 실행해야할 지에 대한 기록을 하는 부분
> 현재 수행중인 JVM 명령어 주소를 가진다.

### Instance Method
> 클래스로 객체를 생성하고 그 객체를 통해서만 호출할 수 있다. \
> 오버라이드가 가능고, 런타임중 동적 바인딩을 통해 메서드의 타입이 결정 된다.

### Heap의 영역 구분
1. Young
- 새롭게 생성된 객체가 할당되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에 많은 객체가 Young 영역에 생성되었다가 사라진다
- Eden, Survivor0, Survivor1 영역으로 구성
- Eden에서 생성되어 Minor GC가 일어 날때마다 살아남은 객체들은 Eden > Survivor0 > Survivor1 > Old 영역으로 이동

2. Old
- Young 영역에서 Reachable 상태를 유지하며 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생
---
* Unreachable : 더 이상 어떤 스레드나 루트에서 참조되지 않는 상태, 즉 GC 대상
* Survivor은 0과1 두개만 존재 (JVM 스펙상)
* Eden이란 객체가 처음 생서되는 Young의 내부의 공간
* Minor GC란 Young 영역에서만 일어나는 GC
* 여러번 참조가 되어 GC에 생존되면 (15회 이상) Old 영역으로 승격된다 -> Old가면 비용이 크기때문에 최대한 안가게 해야함 
* 객체 생명주기 고려해서 설계
---


